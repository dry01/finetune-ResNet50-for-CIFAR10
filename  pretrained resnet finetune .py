# -*- coding: utf-8 -*-
"""ML(Q2 PART-B)ASS-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18WIzFFrTKAqC2RCPzptsidxxsZQdTgH-

Dharamvir ramroop yadav (MT19CPS012)
assignment 2 : question 2(partB)
"""

import torch
import torchvision
import torchvision.transforms as transforms

#install the datasets
transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])

trainset = torchvision.datasets.CIFAR10(root='./data', 
                                        train=True,
                                        download=True, 
                                        transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, 
                                          batch_size=1000,
                                          shuffle=True)

testset = torchvision.datasets.CIFAR10(root='./data', 
                                       train=False,
                                       download=True, 
                                       transform=transform)
testloader = torch.utils.data.DataLoader(testset, 
                                         batch_size=10000,
                                         shuffle=False)

#download pre trained resnet50 data
import torch
import torch.nn as nn
import torchvision.models as models
from torch.autograd import Variable
resnet50 = models.resnet50(pretrained=True)
modules=list(resnet50.children())[:-1]
resnet50=nn.Sequential(*modules)
for p in resnet50.parameters():
    p.requires_grad = False

# only to check the output
use_gpu = torch.cuda.is_available()
resnet = models.resnet50(pretrained=True)
inputs, labels = next(iter(trainloader))
if use_gpu:
    resnet = resnet.cuda()
    inputs, labels = Variable(inputs.cuda()), Variable(labels.cuda())   
else:
    inputs, labels = Variable(inputs), Variable(labels)
outputs = resnet(inputs)
outputs.size()

#replace the last layer and train

def train_model(dataloders, model, criterion, optimizer, scheduler, num_epochs=25):
    since = time.time()
    use_gpu = torch.cuda.is_available()
    best_model_wts = model.state_dict()
    best_acc = 0.0
    

    for epoch in range(num_epochs):
        
        

            running_loss = 0.0
            running_corrects = 0

            for inputs, labels in dataloders:
                if use_gpu:
                    inputs, labels = Variable(inputs.cuda()), Variable(labels.cuda())
                else:
                    inputs, labels = Variable(inputs), Variable(labels)

                optimizer.zero_grad()

                outputs = model(inputs)
                _, preds = torch.max(outputs.data, 1)
                loss = criterion(outputs, labels)

                
                loss.backward()
                optimizer.step()

                running_loss += loss.item()
                running_corrects += torch.sum(preds == labels.data)
            
            
            train_epoch_loss = running_loss / len(labels)
            train_epoch_acc = running_corrects / len(labels)
            
            

            print('Epoch [{}/{}] train loss: {:.4f} acc: {:.4f} ' 
                 .format(
                epoch, num_epochs - 1,
                train_epoch_loss, train_epoch_acc))
        
            
    
    

    model.load_state_dict(best_model_wts)
    return model

from torch.optim import lr_scheduler

resnet = models.resnet50(pretrained=True)
# freeze all model parameters
for param in resnet.parameters():
    param.requires_grad = False

# new final layer with 10 classes
num_ftrs = resnet.fc.in_features
resnet.fc = torch.nn.Linear(num_ftrs, 10)
if use_gpu:
    resnet = resnet.cuda()

criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(resnet.fc.parameters(), lr=0.001, momentum=0.9)
exp_lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)

dloaders = trainloader

import time

start_time = time.time()
model = train_model(dloaders, resnet, criterion, optimizer, exp_lr_scheduler, num_epochs=100)
print('Training time: {:10f} minutes'.format((time.time()-start_time)/60))

import numpy as np

#model accuracy on test images

predicted = []
total_correct = 0
total_images = 0
confusion_matrix = np.zeros([10,10], int)
with torch.no_grad():
    for data in testloader:
        images, labels = data
        images = images.cuda()
        labels = labels.cuda()
        outputs = resnet(images)
        predicted = outputs
        #predicted.append(np.array(outputs)).cuda()
        _, predicted = torch.max(outputs.data, 1)
        #print(predicted)
        total_images += labels.size(0)
        total_correct += (predicted == labels).sum().item()
        for i, l in enumerate(labels):
            confusion_matrix[l.item(), predicted[i].item()] += 1 

model_accuracy = total_correct / total_images * 100
print('Model accuracy on {0} test images: {1:.2f}%'.format(total_images, model_accuracy))

classes = ('plane', 'car', 'bird', 'cat', 'deer', 
           'dog', 'frog', 'horse', 'ship', 'truck')

#classes wise accuracy
print('{0:10s} - {1}'.format('Category','Accuracy'))
for i, r in enumerate(confusion_matrix):
    print('{0:10s} - {1:.1f}'.format(classes[i], r[i]/np.sum(r)*100))

predicted = predicted.cpu()

#confusion matrix for first five classes
confusion_matrix = np.zeros((5,5))

classes5 = np.array([0,1,2,3,4])
for a,b in zip((np.array(labels)),(np.array(predicted))):
  if a in classes5 and b in classes5:
    confusion_matrix[a][b] += 1

confusion_matrix

